//
//  File.swift
//
//
//  Created by Kennedy.Lajustra on 24/12/23.
//

import Foundation

let sampleInput = """
2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533
"""

struct Input {
    let map: [[Int]]
    var visited: [[Bool]]
    let height: Int
    let width: Int
    
    init(string: String) {
        let map = string.split(separator: "\n").map { $0.map { Int(String($0))! } }
        let width = map[0].count
        let height = map.count
        self.map = map
        self.width = width
        self.height = height
        visited = Array(repeating: Array(repeating: false, count: width), count: height)
    }
    
    var debugVisited: String {
        return visited
            .map { line in
                line.map { $0 ? "O" : "." }.joined()
            }
            .joined(separator: "\n")
    }
}

enum Dir: Int, Hashable, CaseIterable {
    case right = 0, down, left, up
    
    var dx: Int {
        switch self {
        case .right: return 1
        case .down: return 0
        case .left: return -1
        case .up: return 0
        }
    }
    var dy: Int {
        switch self {
        case .right: return 0
        case .down: return 1
        case .left: return 0
        case .up: return -1
        }
    }
    
    var char: String {
        switch self {
        case .right:
            return ">"
        case .down:
            return "v"
        case .left:
            return "<"
        case .up:
            return "^"
        }
    }
}

func solve1() {
    var input = Input(string: sampleInput)
    let W = input.width, H = input.height
    
    struct Memo {
        let input: Input
        var memo: [[[Int?]]]
        let W: Int
        let H: Int
        var minDirs: [[Dir?]]
        
        init(input: Input) {
            self.W = input.width
            self.H = input.height
            self.input = input
            memo = Array(repeating: Array(repeating: Array(repeating: nil, count: Dir.allCases.count), count: W), count: H)
            minDirs = Array(repeating: Array(repeating: nil, count: input.width), count: input.height)
        }
        
        func get(_ r: Int, _ c: Int, _ dir: Dir) -> Int? {
            if r == H-1, c == W-1 { return input.map[r][c] }
            return memo[r][c][dir.rawValue]
        }
        
        // source r,c inspect i,j,dir
        mutating func setMin(_ r: Int, _ c: Int, _ sourceDir: Dir,
                             _ i: Int, _ j: Int, _ destDir: Dir,
                             sourceWeight: Int) {
            if let nextMin = get(i, j, destDir) {
                let sourceWeight = sourceWeight
                if let curr = get(r,c,sourceDir), nextMin+sourceWeight < curr {
                    minDirs[r][c] = sourceDir
                }
                memo[r][c][sourceDir.rawValue] = safeMin(get(r, c, sourceDir), nextMin + sourceWeight)
//                if r == 3, c == 4, sourceDir == .right {
//                    print("3,4,down:", memo[r][c][sourceDir.rawValue])
//                }
            }
        }
        
        func debugPrint() {
            for dir in Dir.allCases {
                print("\(dir):")
                for r in 0 ..< H {
                    for c in 0 ..< W {
                        var symb = ".   "
                        if let v = get(r, c, dir) {
                            symb = String(v).padding(toLength: 4, withPad: " ", startingAt: 0)
                        }
                        print(symb, terminator: " ")
                    }
                    print("")
                }
                print("")
            }
            
            print("min dir:")
            for r in 0 ..< H {
                for c in 0 ..< W {
                    if let dir = minDirs[r][c] {
                        print(dir.char.padding(toLength: 4, withPad: " ", startingAt: 0), terminator: " ")
                    } else {
                        print(".   ", terminator: " ")
                    }
                }
                print("")
            }
            print("\n")
        }
    }
    
    var memo = Memo(input: input)
    
    func scanVertical() {
        let rowDiff = [1, 2, 3, -1, -2, -3]
        let dirs: [Dir] = [.down, .down, .down, .up, .up, .up]
        let nextDirs: [Dir] = [.left, .right]
        var r = H-1
        while r >= 0 {
            var c = W-1
            while c >= 0 {
                // r,c current tile
                for (dir,dr) in zip(dirs,rowDiff) {
                    // i,j next tile
                    var i = r + dr
                    let j = c
                    guard withinBounds(r: i, c: j) else { continue }
                    
                    // sum of weight from [r..i),c or (i..r],c
                    let weight = {
                        var result = 0
                        for row in stride(from: r, to: i, by: 1) {
                            result += input.map[row][c]
                        }
                        for row in stride(from: r, to: i, by: -1) {
                            result += input.map[row][c]
                        }
                        return result
                    }()
//                    if c == W-1, r >= H-1-3 {
//                        print("sum weight: \(r),\(c) to \(i),\(j) dir:\(dir)", weight)
//                    }
                    for nextDir in nextDirs {
                        memo.setMin(r, c, dir, i, j, nextDir, sourceWeight: weight)
                    }
                }
                c -= 1
            }
            r -= 1
        }
    }
    
    func scanHorizontal() {
        let colDiff = [1, 2, 3, -1, -2, -3]
        let dirs: [Dir] = [.right, .right, .right, .left, .left, .left]
        let nextDirs: [Dir] = [.up, .down]
        var r = H-1
        while r >= 0 {
            var c = W-1
            while c >= 0 {
                // r,c current tile
                for (dir, dc) in zip(dirs, colDiff) {
                    // i,j next tile
                    var i = r
                    let j = c + dc
                    guard withinBounds(r: i, c: j) else { continue }
                    // sum of weight from r,[c..j) or (j..c]
                    let weight = {
                        var result = 0
                        for col in stride(from: c, to: j, by: 1) {
                            result += input.map[r][col]
                        }
                        for col in stride(from: c, to: j, by: -1) {
                            result += input.map[r][col]
                        }
                        return result
                    }()
                    for nextDir in nextDirs {
                        memo.setMin(r, c, dir, i, j, nextDir, sourceWeight: weight)
                    }
                }
                c -= 1
            }
            r -= 1
        }
    }
    
    let consecutiveMoves = 3
    let dist = W+H
    for _ in 0 ..< dist*2 {
        scanVertical()
        scanHorizontal()
        memo.debugPrint()
        let _ = readLine()
    }
    
    print("part1:", safeMin(memo.get(0, 0, .right), memo.get(0, 0, .down)))
    
    
    func withinBounds(r: Int, c: Int) -> Bool {
        return 0 <= r && r < H && 0 <= c && c < W
    }
    
    func safeMin(_ a: Int?, _ b: Int?) -> Int? {
        if let a, let b {
            return min(a, b)
        } else if let a {
            return a
        } else if let b {
            return b
        } else {
            return nil
        }
    }
}

solve1()

